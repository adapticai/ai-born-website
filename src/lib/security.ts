/**
 * Security utilities for CSP nonce handling and security-related functions
 */

import { headers } from "next/headers";

/**
 * Get the CSP nonce from request headers (server components only)
 *
 * This nonce is generated by the middleware and can be used for inline scripts
 * that need to comply with Content Security Policy.
 *
 * @returns The CSP nonce string or undefined if not available
 *
 * @example
 * ```tsx
 * import { getNonce } from '@/lib/security';
 *
 * export default function Page() {
 *   const nonce = getNonce();
 *   return (
 *     <script nonce={nonce} dangerouslySetInnerHTML={{
 *       __html: `console.log('This script uses CSP nonce');`
 *     }} />
 *   );
 * }
 * ```
 */
export async function getNonce(): Promise<string | undefined> {
  const headersList = await headers();
  return headersList.get("x-nonce") || undefined;
}

/**
 * Sanitize user input to prevent XSS attacks
 *
 * This is a basic sanitization utility. For production use with user-generated
 * HTML content, consider using a library like DOMPurify.
 *
 * @param input - The user input to sanitize
 * @returns Sanitized string safe for HTML contexts
 */
export function sanitizeInput(input: string): string {
  return input
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#x27;")
    .replace(/\//g, "&#x2F;");
}

/**
 * Validate email address format
 *
 * @param email - Email address to validate
 * @returns True if email format is valid
 */
export function isValidEmail(email: string): boolean {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}

/**
 * Generate a secure random token
 *
 * Useful for CSRF tokens, session identifiers, etc.
 *
 * @param length - Length of the token (default: 32)
 * @returns Base64-encoded random token
 */
export function generateSecureToken(length: number = 32): string {
  const buffer = new Uint8Array(length);
  crypto.getRandomValues(buffer);
  return Buffer.from(buffer).toString("base64url");
}

/**
 * Hash a string using SHA-256
 *
 * Useful for hashing sensitive data like order IDs in analytics
 *
 * @param input - String to hash
 * @returns Hex-encoded SHA-256 hash
 */
export async function hashString(input: string): Promise<string> {
  const encoder = new TextEncoder();
  const data = encoder.encode(input);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
}

/**
 * Check if a URL is safe (internal or whitelisted external)
 *
 * @param url - URL to check
 * @param allowedDomains - Optional array of allowed external domains
 * @returns True if URL is safe to use
 */
export function isSafeURL(url: string, allowedDomains: string[] = []): boolean {
  try {
    const parsedURL = new URL(url, process.env.NEXT_PUBLIC_SITE_URL || "https://ai-born.org");

    // Allow relative URLs
    if (url.startsWith("/") && !url.startsWith("//")) {
      return true;
    }

    // Check if it's our own domain
    const siteDomain = new URL(
      process.env.NEXT_PUBLIC_SITE_URL || "https://ai-born.org"
    ).hostname;
    if (parsedURL.hostname === siteDomain || parsedURL.hostname === "localhost") {
      return true;
    }

    // Check against allowed domains
    return allowedDomains.some((domain) => {
      if (domain.startsWith("*.")) {
        const baseDomain = domain.slice(2);
        return parsedURL.hostname.endsWith(baseDomain);
      }
      return parsedURL.hostname === domain;
    });
  } catch {
    return false;
  }
}

/**
 * Rate limiting check for form submissions
 *
 * Use this in API routes to prevent spam and abuse
 *
 * @param identifier - Unique identifier (IP, email, etc.)
 * @param store - Rate limit store (Map or similar)
 * @param maxRequests - Maximum requests allowed
 * @param windowMs - Time window in milliseconds
 * @returns True if rate limit is exceeded
 */
export function isRateLimited(
  identifier: string,
  store: Map<string, { count: number; resetTime: number }>,
  maxRequests: number = 10,
  windowMs: number = 60 * 60 * 1000 // 1 hour
): boolean {
  const now = Date.now();
  const record = store.get(identifier);

  if (!record || now > record.resetTime) {
    store.set(identifier, { count: 1, resetTime: now + windowMs });
    return false;
  }

  if (record.count >= maxRequests) {
    return true;
  }

  record.count += 1;
  store.set(identifier, record);
  return false;
}

/**
 * Clean up expired rate limit entries
 *
 * Call this periodically to prevent memory leaks in rate limit stores
 *
 * @param store - Rate limit store to clean
 */
export function cleanupRateLimitStore(
  store: Map<string, { count: number; resetTime: number }>
): void {
  const now = Date.now();
  for (const [key, value] of store.entries()) {
    if (now > value.resetTime) {
      store.delete(key);
    }
  }
}

/**
 * Validate and sanitize file upload
 *
 * Use this to validate proof of purchase uploads for bonus claims
 *
 * @param file - File object from upload
 * @param options - Validation options
 * @returns Validation result with error message if invalid
 */
export interface FileValidationOptions {
  maxSizeMB?: number;
  allowedTypes?: string[];
  allowedExtensions?: string[];
}

export interface FileValidationResult {
  valid: boolean;
  error?: string;
}

export function validateFile(
  file: File,
  options: FileValidationOptions = {}
): FileValidationResult {
  const {
    maxSizeMB = 5,
    allowedTypes = ["image/jpeg", "image/png", "image/gif", "image/webp", "application/pdf"],
    allowedExtensions = [".jpg", ".jpeg", ".png", ".gif", ".webp", ".pdf"],
  } = options;

  // Check file size
  const maxBytes = maxSizeMB * 1024 * 1024;
  if (file.size > maxBytes) {
    return {
      valid: false,
      error: `File size exceeds ${maxSizeMB}MB limit`,
    };
  }

  // Check file type
  if (!allowedTypes.includes(file.type)) {
    return {
      valid: false,
      error: `File type ${file.type} is not allowed`,
    };
  }

  // Check file extension
  const extension = file.name.toLowerCase().slice(file.name.lastIndexOf("."));
  if (!allowedExtensions.includes(extension)) {
    return {
      valid: false,
      error: `File extension ${extension} is not allowed`,
    };
  }

  return { valid: true };
}
